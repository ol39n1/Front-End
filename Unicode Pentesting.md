# Comprehensive Guide to Unicode Security Vulnerabilities

## Character Encoding Vulnerabilities

Character encodings define how bytes are converted to characters in a computing system. Vulnerabilities arise when systems inconsistently handle or interpret these encodings.

### Common Attack Vectors

#### 1. Character Encoding Confusion

Attacks exploit inconsistencies between how different parts of an application interpret character encodings.

```
Example: An application validates input in UTF-8 but processes it as ISO-8859-1
Input: "%C0%AE%C0%AE/" (UTF-8 overlong encoding of "../")
Result: Path traversal attack succeeds despite validation
```

#### 2. UTF-7 Injection Attacks

UTF-7 is a legacy encoding that can bypass XSS filters on older systems.

```html
<!-- UTF-7 encoded JavaScript -->
+ADw-script+AD4-alert('XSS')+ADw-/script+AD4-

<!-- Which decodes to: -->
<script>alert('XSS')</script>
```

This attack can succeed when:
- The page doesn't specify a character encoding, allowing the browser to interpret it as UTF-7
- The application filters input in one encoding but renders in another

#### 3. Byte Order Mark (BOM) Manipulation

The Byte Order Mark (U+FEFF) can be used to confuse parsers:

```
// Inserting a BOM in the middle of a parameter
username=admin%EF%BB%BF&password=password
```

This might cause the application to truncate the username at the BOM, processing "admin" instead of the full value.

#### 4. Overlong UTF-8 Encodings

UTF-8 allows characters to be represented in multiple ways:

```
Standard encoding of "/" = 0x2F
Overlong encoding of "/" = 0xC0 0xAF or 0xE0 0x80 0xAF
```

Filters that check for "/", "..", or other special characters might miss overlong encodings.

### Bypass Encoding Detection Mechanisms

#### 1. Encoding Layering

By applying multiple encodings, attackers can bypass detection:

```
Original: <script>alert(1)</script>
URL encoded: %3Cscript%3Ealert(1)%3C%2Fscript%3E
Double encoded: %253Cscript%253Ealert(1)%253C%252Fscript%253E
```

If an application decodes input once before validation but twice before processing, this attack can succeed.

#### 2. Mixed Encoding Attacks

Mixing encoding types can bypass filters that handle only one encoding:

```
<scr%u0069pt>alert(1)</script>  // Mixes URL encoding and Unicode escapes
```

#### 3. Character Set Shifting

Some legacy encodings support shifting between character sets:

```
// ISO-2022-JP encoding with shifts between character sets
\x1B$B\x24\x22\x1B(B  // Shifts to JIS and back
```

This can confuse parsers that don't properly handle character set shifts.

### Practical Examples and Case Studies

#### Case Study: UTF-7 XSS in Legacy Systems

In 2007, several webmail systems were vulnerable to UTF-7 XSS attacks because:
1. They allowed users to upload HTML content
2. They didn't specify a content-type or charset
3. IE6/7 would interpret content as UTF-7 if it started with a UTF-7 BOM (+/v8)

```
+ADw-img src=+ACI-#+ACI- onerror=+ACI-alert(document.cookie)+ACI- /+AD4-
```

#### Case Study: SQL Injection via Character Encoding

In 2013, an application was vulnerable to SQL injection despite prepared statements:
1. Web form accepted UTF-8 input
2. Application validated input for SQL injection patterns in UTF-8
3. Database connection used latin1 encoding
4. When input was stored, certain UTF-8 sequences became valid SQL operators in latin1

```
Parameter containing UTF-8: "admin%C0%A7" 
When converted to latin1: "admin§" (where § becomes a valid SQL operator)
```

### Detection and Mitigation

1. **Explicitly specify character encodings** in HTTP headers and HTML meta tags:
   ```http
   Content-Type: text/html; charset=UTF-8
   ```
   ```html
   <meta charset="UTF-8">
   ```

2. **Canonicalize input** before validation:
   ```javascript
   // Node.js example
   function canonicalize(input) {
     // Convert to Unicode and back to UTF-8
     return Buffer.from(input).toString('utf8');
   }
   ```

3. **Reject invalid or suspicious encodings**:
   ```javascript
   function isValidUTF8(input) {
     try {
       const decoded = new TextDecoder('utf-8', {fatal: true}).decode(input);
       return true;
     } catch (e) {
       return false;  // Invalid UTF-8
     }
   }
   ```

4. **Use consistent encoding** throughout the entire application stack

## Unicode Normalization Attacks

Unicode normalization converts characters to a standardized form. Security issues arise when systems inconsistently apply normalization.

### Normalization Fundamentals for Security

There are four standard Unicode normalization forms:

| Form | Description | Security Implications |
|------|-------------|----------------------|
| NFC  | Canonical Decomposition + Composition | Most compact form, commonly used |
| NFD  | Canonical Decomposition | Characters decomposed into base + combining marks |
| NFKC | Compatibility Decomposition + Composition | Compatible characters collapsed to equivalents |
| NFKD | Compatibility Decomposition | Most extensively decomposed form |

### How Normalization Can Be Exploited

#### 1. Normalization Form Confusion

Different system components might use different normalization forms:

```
User input: "café" (NFC form with precomposed é)
System normalizes to NFD for validation: "cafe" + combining accent
System stores as provided in NFC: "café"
Another component expects NFD: fails to match
```

#### 2. Incomplete Normalization

When normalization is incorrectly implemented:

```javascript
// Buggy normalization function
function badNormalize(input) {
  // Only handles common cases, misses edge cases
  return input.replace('é', 'e');  // Misses other compositions
}
```

#### 3. Input Canonicalization Bypass

Validation filters might be bypassed:

```
Blocked word: "admin"
Input using combining marks: "a\u0304dmin" (a + combining macron)
If system normalizes after validation: "ādmin" passes filter
```

### Attacks Using Different Normalization Forms

#### 1. Authentication Bypass

```
Username database: "admin" (stored in NFC)
Attacker submits: "a\u0304dmin" (a + combining character)
If comparison doesn't normalize: authentication fails for valid user
If authorization checks normalize differently: privilege escalation
```

#### 2. Cross-Site Scripting (XSS)

```html
<!-- Blocked by filter: -->
<script>alert(1)</script>

<!-- Bypasses filter using decomposed characters: -->
<s\u0063ript>alert(1)</script>
```

#### 3. File Path Normalization

```
Blocked path pattern: "../admin/"
Attack using decomposed form: "..\/a\u0304dmin/"
```

### Case Studies of Normalization Vulnerabilities

#### Case Study: OAuth Authentication Bypass

In 2020, a critical vulnerability affected several OAuth implementations:
1. User registered with username "users\u2060admin" (with zero-width joiner)
2. System normalized during registration, storing "usersadmin"
3. Authentication didn't normalize similarly, allowing login as "users\u2060admin"
4. Authorization still checked against "usersadmin" permissions
5. Result: Attacker gained admin privileges

#### Case Study: MongoDB Normalization Issue (CVE-2020-7929)

MongoDB prior to 4.2.8 didn't properly normalize Unicode strings when checking permissions:
1. Database had collection named "users"
2. Attacker created collection named "u\u0308sers" (u + combining diaeresis)
3. Some MongoDB operations normalized this to "users"
4. Attacker gained access to the "users" collection

### Mitigation Strategies

1. **Apply consistent normalization** throughout the application:
   ```javascript
   function secureCompare(str1, str2) {
     // Normalize both strings to the same form (NFKC recommended for security)
     const normalized1 = str1.normalize('NFKC');
     const normalized2 = str2.normalize('NFKC');
     return normalized1 === normalized2;
   }
   ```

2. **Normalize before validation and storage**:
   ```javascript
   function validateAndStore(input) {
     const normalized = input.normalize('NFKC');
     if (isValid(normalized)) {
       storeInDatabase(normalized);
       return true;
     }
     return false;
   }
   ```

3. **Document normalization policies** as part of security protocols

## Homograph Attacks

Homograph attacks exploit characters that appear visually identical or very similar but have different Unicode code points.

### Understanding Homographs

There are several types of homographs:

1. **Cross-script homographs**: Similar characters from different scripts
   - Latin 'a' (U+0061) vs Cyrillic 'а' (U+0430)
   - Latin 'p' (U+0070) vs Cyrillic 'р' (U+0440)

2. **Same-script homographs**: Similar characters within the same script
   - Latin lowercase 'l' (U+006C) vs Latin uppercase 'I' (U+0049)
   - Digit '0' (U+0030) vs Latin uppercase 'O' (U+004F)

3. **Mixed-script confusables**: Sequences that combine scripts
   - "paypal" vs "pаypal" (second has Cyrillic 'а')

### IDN Homograph Attacks in URLs

Internationalized Domain Names (IDNs) can be used for phishing:

```
Legitimate: apple.com
Homograph attack: аpple.com (with Cyrillic 'а')

Legitimate: paypal.com
Homograph attack: рaypal.com (with Cyrillic 'р')
```

When displayed in browsers, these can appear identical, leading users to phishing sites.

#### Punycode Representation

IDNs are represented in DNS using Punycode:

```
аpple.com → xn--pple-43d.com
```

Modern browsers implement various safeguards:
- Display Punycode for suspicious domains
- Show warnings for mixed-script domains
- Highlight IDNs in the address bar

### Exploiting Homographs in Filenames or Displayed Content

#### 1. Malicious File Distribution

```
Legitimate: financial_report.pdf
Homograph attack: financіal_report.pdf (with Cyrillic 'і')
```

The attack file might be malware that appears legitimate to users.

#### 2. Source Code Attacks

```python
# Original code
userRole = getUserRole(userId)
if userRole == "admin":
    grantAdminAccess()

# Modified with homograph
userRoIe = getUserRole(userId)  # 'l' replaced with capital 'I'
if userRole == "admin":  # This check now always fails
    grantAdminAccess()
```

This creates a security flaw that's difficult to detect visually.

#### 3. Data Exfiltration through Homographs

Attackers can use homographs to bypass data loss prevention systems:

```
Blocked keyword: "confidential"
Bypass using homographs: "confidentіal" (with Cyrillic 'і')
```

### Detection and Prevention

#### 1. Script Restriction Policies

Limit allowed scripts in sensitive contexts:

```javascript
function isSingleScript(text) {
  // Get script for each character (simplified)
  const scripts = new Set();
  
  for (const char of text) {
    scripts.add(getScript(char));
    if (scripts.size > 1) return false;
  }
  
  return true;
}
```

#### 2. Confusable Detection

Identify potentially confusable characters:

```javascript
const confusables = {
  'а': ['a'], // Cyrillic 'а' looks like Latin 'a'
  'е': ['e'], // Cyrillic 'е' looks like Latin 'e'
  'о': ['o'], // Cyrillic 'о' looks like Latin 'o'
  // more mappings...
};

function hasConfusables(text) {
  for (const char of text) {
    if (confusables[char]) return true;
  }
  return false;
}
```

#### 3. Visual Indicators and Education

```javascript
function displayDomainWarning(domain) {
  if (hasConfusables(domain)) {
    showWarningBanner("This domain contains characters that may be deceptive.");
    highlightConfusableChars(domain);
  }
}
```

## BIDI Attacks

Bidirectional (BIDI) attacks exploit the Unicode Bidirectional Algorithm, which manages the display of mixed right-to-left (RTL) and left-to-right (LTR) text.

### Bidirectional Algorithm Basics

The Unicode Bidirectional Algorithm uses several control characters:

| Character | Unicode | Description |
|-----------|---------|-------------|
| LRE | U+202A | Left-to-Right Embedding |
| RLE | U+202B | Right-to-Left Embedding |
| LRO | U+202D | Left-to-Right Override |
| RLO | U+202E | Right-to-Left Override |
| PDF | U+202C | Pop Directional Formatting |
| LRI | U+2066 | Left-to-Right Isolate |
| RLI | U+2067 | Right-to-Left Isolate |
| FSI | U+2068 | First Strong Isolate |
| PDI | U+2069 | Pop Directional Isolate |

### How BIDI Can Be Leveraged in Attacks

#### 1. File Extension Spoofing

```
filename.txt‮exe.‬

Visual display: filename.exe.txt
Actual name: filename.txt[RLO]exe.[PDF]
```

The file appears to be a harmless .txt file but is actually an executable.

#### 2. Code Obfuscation

```javascript
var /* ‮ } ⁦if (isAdmin)⁩ ⁦ begin admins only */ isAdmin=false;
```

This might appear as a comment but actually contains executable code that changes the `isAdmin` value.

#### 3. Message Manipulation in Chat Apps

```
User sends: I agree to pay $100‮001$‬ for this item

Visual display: I agree to pay $1000$ for this item
Actual meaning: I agree to pay $100[RLO]001$[PDF] for this item
```

This makes it appear the user agreed to pay $1000 when they only agreed to $100.

### Examples of Misleading Content

#### 1. Malicious Commands with Hidden Segments

```bash
cat harmless_file.txt‮ > rm -rf /* #‬
```

This appears to display the contents of a harmless file but actually executes a destructive command.

#### 2. URL Manipulation

```
https://bank.com/login?redirect=https://‮moc.elgoog.evil//:sptth‬
```

This URL might appear to redirect to a Google domain but actually points elsewhere.

#### 3. Source Code Backdoors

```python
def check_auth(user):
    # ‮rotartsinimda‬ = user # Check if admin
    return True  # Always authenticate
```

This code has a disguised comment that appears to check authentication but always returns True.

### Recent BIDI Attack Research

In 2021, researchers published "Trojan Source: Invisible Vulnerabilities" revealing how BIDI control characters could introduce vulnerabilities in source code across multiple programming languages:

1. **Comment-Statement Confusion**: Code that appears commented out but executes
2. **String Literal Reordering**: Manipulating strings to display differently than how they're processed
3. **Stretched Tokens**: Visual characters spanning multiple tokens

```c
// Example from the research
if (isAdmin) {
/* begin admin only */ ‮ } if (isAdmin) { ⁦ /* end admin only */
    deleteAllUsers();
}
```

### Mitigating BIDI-Related Vulnerabilities

#### 1. Strip or Block BIDI Controls

```javascript
function stripBidiControls(input) {
  return input.replace(/[\u2066-\u2069\u202A-\u202E\u061C]/g, '');
}
```

#### 2. Visual Indicators for BIDI Content

```javascript
function highlightBidiControls(text) {
  // Replace BIDI controls with visible markers
  return text.replace(/[\u2066-\u2069\u202A-\u202E\u061C]/g, char => {
    return `<span class="bidi-control" title="Unicode: ${char.codePointAt(0).toString(16)}">⚠</span>`;
  });
}
```

#### 3. Consistent Bidirectional Policy

```javascript
// Enforce consistent directionality
function enforceLTR(text) {
  // Force LTR context and strip BIDI controls
  return '\u2066' + stripBidiControls(text) + '\u2069';
}
```

#### 4. Code Repository Protections

```javascript
// Pre-commit hook to detect BIDI controls in source code
function detectBidiInSource(sourceCode) {
  const bidiPattern = /[\u2066-\u2069\u202A-\u202E\u061C]/;
  if (bidiPattern.test(sourceCode)) {
    console.error("SECURITY WARNING: BIDI controls detected in source code");
    return false;  // Reject commit
  }
  return true;
}
```

## Integrated Defense Strategies

### 1. Input Sanitization

Implement a comprehensive sanitization pipeline:

```javascript
function sanitizeInput(input) {
  // Step 1: Normalize to a consistent form
  let sanitized = input.normalize('NFKC');
  
  // Step 2: Strip or escape dangerous control characters
  sanitized = stripBidiControls(sanitized);
  
  // Step 3: Check for homographs/confusables
  if (hasConfusables(sanitized)) {
    throw new Error('Potential homograph attack detected');
  }
  
  // Step 4: Validate script mixing
  if (!isSafeScriptCombination(sanitized)) {
    throw new Error('Unsafe script combination detected');
  }
  
  return sanitized;
}
```

### 2. Defense in Depth

Implement multiple layers of protection:

```javascript
class UnicodeSecurityPipeline {
  constructor(options = {}) {
    this.allowedScripts = options.allowedScripts || ['Latin', 'Common'];
    this.normalizeForm = options.normalizeForm || 'NFKC';
    this.allowBidiControls = options.allowBidiControls || false;
  }
  
  process(input) {
    let processed = input;
    
    // Normalization
    processed = processed.normalize(this.normalizeForm);
    
    // BIDI controls
    if (!this.allowBidiControls) {
      processed = this.stripBidiControls(processed);
    }
    
    // Script validation
    this.validateScripts(processed);
    
    // Homograph detection
    this.detectHomographs(processed);
    
    return processed;
  }
  
  // Implementation of component methods...
}
```

### 3. Context-Specific Rules

Apply different rules based on the context:

```javascript
function applySecurityRules(input, context) {
  switch (context) {
    case 'username':
      return applyStrictUsernameSecurity(input);
    
    case 'displayName':
      return applyDisplayNameSecurity(input);
    
    case 'email':
      return applyEmailSecurity(input);
    
    case 'url':
      return applyUrlSecurity(input);
    
    case 'sourceCode':
      return applySourceCodeSecurity(input);
      
    default:
      return applyDefaultSecurity(input);
  }
}
```

### 4. Regular Expression Considerations

Unicode-aware regular expressions are crucial:

```javascript
// Without Unicode flag - potentially unsafe
const nonUnicodeRegex = /[a-z]+/;

// With Unicode flag - safer for international text
const unicodeRegex = /\p{Script=Latin}+/u;

// Testing
unicodeRegex.test('abc'); // true
unicodeRegex.test('абв'); // false (Cyrillic)
```

### 5. User Education and Interface Design

Integrate warnings into the user interface:

```javascript
function displaySecurityInfo(element, text) {
  if (hasBidiControls(text)) {
    element.classList.add('bidi-warning');
    addTooltip(element, 'This text contains bidirectional controls');
  }
  
  if (hasMultipleScripts(text)) {
    element.classList.add('script-mixing-warning');
    addTooltip(element, 'This text mixes different writing systems');
  }
  
  if (hasConfusables(text)) {
    element.classList.add('confusable-warning');
    addTooltip(element, 'This text contains potentially confusing characters');
  }
}
```

## Conclusion

Unicode security vulnerabilities present significant challenges in our increasingly international digital landscape. By understanding the mechanics of character encoding attacks, normalization vulnerabilities, homograph attacks, and BIDI exploits, developers can implement robust defenses:

1. **Always normalize** input using consistent rules (NFKC recommended for security contexts)
2. **Implement context-specific sanitization** based on the input's purpose
3. **Apply script restrictions** where appropriate
4. **Detect and handle confusable characters** to prevent homograph attacks
5. **Strip or safely handle BIDI control characters** in sensitive contexts
6. **Provide visual indicators** for potentially deceptive content
7. **Stay informed** about emerging Unicode security research and attacks

By integrating these practices into security workflows, applications can safely support international text while mitigating Unicode-specific security risks.
